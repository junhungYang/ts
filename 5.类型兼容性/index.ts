interface Duck {
  sound: '嘎嘎嘎'
  swin(): void
}

let person = {
  name: '伪装成鸭子的人',
  sex: 'male',
  sound: '嘎嘎嘎' as '嘎嘎嘎',
  swin() {
    console.log(`${this.name}正在${this.sound}叫`)
  }
}

const duck: Duck = person

// as 修饰符为类型断言，即指定sound属性只能是字符串类型中的'嘎嘎嘎'
// 与 let a:'嘎嘎嘎' 原理一致，再 接口中要求 sound 属性必须是类型 '嘎嘎嘎'
// 而{sound: '嘎嘎嘎'} 只能代表sound属性只能是字符串类型并且当前的值为'嘎嘎嘎'
// 而不能代表sound属性必须是'嘎嘎嘎'类型，所以应该添加上 as 进行类型断言


// 直接字面量赋值的差异

// ts要求直接字面量赋值不能允许存在类型约束以外的属性或方法，原因是当你已经清楚
// 这是一只鸭子，你还刻意赋予他鸭子以外的特征那是不符合常理的，而一个变量赋值给另一个变量
// 之所以允许的原因是，很多时候 我们只能确定用于赋值的变量具有另一变量要求的类型，
// 但不能确认他有没有其他多余的类型，所以这种情况下是允许的

// 非必填类型
interface User {
  name?: string //非必填
  age: number
}

let u: User = {
  age:18,
  // nema:'junxing'  在字面量的情况下，手误写错的情况会报错原因同上
}
// ---------

let u1 = {
  nema: 'junxing',
  age: 19
}
u = u1

// 但在该情况下不报错，首先前提条件是我们一般不会这样写，假如仅仅是去赋值一个对象，
// 那么可以直接使用字面量，而该情况其实是针对以下情况

function sendRequest () {
  // 发送请求,返回数据
  return {
    nema: 'juxning',
    age: 19
  }
}

u = sendRequest()

// 情况其实是主要针对 在一个函数中获得了一堆数据的情况，而究竟函数中会返回什么数据
// 是说不定的，而我们只能确保这些数据中必然存在一个age数据。这种情况下就适用鸭子辨型法了。

