# 装饰器
面向对象的概念（java: 注解， c#: 特征），decorator

# 解决的问题
  -装饰器，能够带来额外的信息量，达到分离关注点的目的

- 关注点问题：再定义某个东西时，应该最先清楚该东西的情况
- 重复代码的问题

上述两个问题产生的根源： 某些信息，在定义时，能够附加的信息量有限

装饰器的作用：为某些属性，类，参数，方法提供元数据信息（描述数据的数组）

## 装饰器的本质
  在JS中，装饰器时一个函数，装饰器是要参与运行的

  装饰器可以修饰
  - 类
  - 成员
  - 参数

在TS中要使用装饰器，需要在配置中开启 ```experimentalDecorators```

装饰器的运行时间： 在类定义后直接运行

类装饰器可以具有的返回值： 
 -void: 仅运行函数  
 -一个新的类: 会将新的类替换掉所装饰的类(但该操作得不到类型检查)


# 成员装饰器
- 属性
 属性装饰器是一个函数，该函数会获得两个参数
 1. 如果是静态属性，则为类本身；如果是实例属性，则为类的原型
 2. 固定为一个字符串，表示属性名

- 方法
 方法装饰器也是一个函数，该函数会获得三个参数
 1. 如果是静态方法，则为类本身；如果是实例方法，则为类的原型
 2. 固定为一个字符串，表示方法名
 3. 方法的描述符对象 （使用Object.defineProperty 所传入的 配置对象）

 # reflect-metadata库

 # class-validator库

 # class-transformer库 
  可以将一个平面对象(plain object)转换为一个类的对象
  场景：后台返回了一串用户信息，其中包含name属性，前端有一个user类，该类具备后台返回的用户对象的属性，以及getName方法，class-transformer可以将后台返回的平面对象转换为类的对象（plainToClass），
  该对象可以使用getName方法

# 补充
- 参数装饰器
  依赖注入，依赖倒置
  要求函数有三个参数
  1. 如果方法是静态的则为类本身；如果方法是实例方法，则为类的原型
  2. 方法名称
  3. 在参数里列表中的索引

- 关于TS自动注入的元数据
  如果安装了```reflect-metadata```, 并且导入了该库，并且在某个成员上添加了元数据，并且启动了 ``` emitDecoratorMetadata ```

  则TS在编译结果中，会将约束的类型，作为元数据假如到相应位置，
  简单而言 就是 只在书写代码时进行的类型约束，依然会在编译后生效

- AOP （aspect oriented programming）
  编程方式，属于面向对象开发
  将一些在业务中共同出现的功能块，横向切分，已达到分离关注点的目的，例如：存在一个保存用户至数据库的功能save，保存之前需进行验证，
  由于不只是当前场景其他场景中也经常使用到验证，其次验证规则又会有很多，此时就可以将验证的功能单独抽离出来作为一个切面，在这个横切面
  上我们就只需要关注如何书写整个验证流程，而不需要关注其在整个垂直业务流程中 上方或下方的业务流程